# Intelligent Placer

## Словарь 
Предмет - физический объект, запечатлённый на фотографиях из датасета (см data)
Алгоритм - последовательность шагов, которая получает на вход объекты из заранее определенного множества и либо останавливается и возвращает какое-то значение, либо возвращает ошибку(Exception)

## Наименование и цель работ
**Наименование:** разработка и поставка алгоритма для проверки возможности расположения предметов внутри многоугольника по снимку предметов и контура многоугольника 

**Цель:** разработка програмного кода, реализующего алгоритм распознающий предметы из фиксированного списка и проверяющий возможность расположить предметы внутри многоугольника

## Наименование Заказчика и Исполнителя
**Заказчик:** adts-----@bk.ru + vikt-----@gmail.com 

**Исполнитель:** Марин Е.В.

## Содержание работ  
Работы включают в себя:
- Разработку и поставку библиотеки, реализующей алгоритм для распознавания предметов и проверки возможности расположить предметы внутри многоугольник. Библиотека должна быть написана на языке python и должна поставлять функцию со следующим прототипом: def check_image(<path_to_png_jpg_image_on_local_computer>);
- Подготовку инструкции с перечислением шагов, необходимых для запуска когда на локальном устрйостве заказчика; (зависимости, venv, python, ...) 
- Проведение показательного эксперемента на репрезентативных данных для демонстрации работоспособности алгоритма;
- Написание отчёта по проделанной работе. 

## Требования к входнным данным
- Алгоритм принимает на вход путь к файлу, содержащему растровую фотографию в одном из общепринятых форматов (.jpg, .png).
- Файл должен содержаться на том же устройстве, на котором исполняется исходный код. Загрузка файлов из облачного хранилища не предусмотрена.
- Фотография должна содержать любое подмножество предметов, утверждённых с заказчиком, расположенных под листом бумаги А4, на котором темной непрерывной линией нарисован многоугольник.
- Лист бумаги должен быть чистым и должен быть расположен на фотографии так, чтобы длиннейшая его сторона проходила слева направо.
- Предметы должны быть строго разделены между собой более, чем на 4 пикселя и должны быть отделены от листа бумаги на расстояние более 4 пикселей. (предметы не лежат на листке или друг на друге)
- Предметы должны сохранять свою конфигурацию на всех снимках. (например, ручка с колпачком и ручка без колпачка - это разные предметы, телефон экраном вниз и телефон экраном вверх - это разные предметы, телефон, повернутый относительно нормали к своему экрану под любым углом - это один и тот же предмет)
- Один предмет не может присутствовать на входной фотографии в нескольких копиях.
- Фотографии должны быть сделаны серху-вниз. (угол отклонения объектива от вертикали при фотографировании не более 30 градусов)
- На фотографии не должно прсиутствовать артефактов, связанных с плохой освещённостью. (нету засветов, тёмных участков, ярких пятен, вызванных окрашенным освещением высокой интенсивности)
- Разрешение фотографий не менее 1280х800.

## Описание ожидаемого использования програмного продукта
1. Фотография, подходящая по всем критериям из предыдущего пункта загружается в файловую систему, в которой расположен исходный код программы;
2. Исходный код запускается в заранее подготовленном окружении, содержащем все необходимые зависимости. В качестве параметра, функция check_image принимает путь к файлу, харнящему входное изображение;
3. В качестве выходных данных функция возвращает одно из трёх значений: True/False/None. (True - данные корректны, предметы нельзя поместить в многоугольник; False - данные корректны, предметы можно поместить в многоугольник; None - данные не прошли валидацию и ответ не может быть получен)

## ВТОРАЯ ИТЕРАЦИЯ
### Распознавание
- Исследовать файлы с объектами для выявления оптимальных параметров для детекции
- Сжать изображение для ускорения операций
- Провести бинаризацию изображения с помощью алгоритма Канни
- Сгладить маску посредством морфологического закрытия
- Найти контуры на бинарной маске
- Отфильтровать контуры, соответствующие шумам по площади

### Укладка
Укладка производится с помощью генетической оптимизации функции потерь (см блокнот)   
Идея функции потерь: (сумма площади пересечений внутри контура) + (сумма площадей выходов за границу контура) * M  (M>>1)    
Зависит она от 3*(число объектов) параметров: сдвиг по x / сдвиг по y / угол вращения для кажого объекта  
Такая функция позволяет быстро найти основное поле описка для генетического алгоритма, "загоняя" объекты внутрь многоугольника  

Параметры генетической оптимизации потерь:  
- Число итераций: 40 (не может быть большим из-за трудоёмкости вычислений функции потерь)  
- Размер популяции: 60 (не может быть большим из-за трудоёмкости вычислений функции потерь)  
- Вероятность мутации: 0.15 (относительно невысокая вероятность, т.к. поле поиска невелико)  
- Доля элит: 0.05 (относительно невысокая доля элит, т.к. в малой популяции хромосом опасно выделять большое число неприкосновенных элементов)  
- Вероятность скрещивания: 0.5 (стандартное значение)  
- Тип скрещивания: "two_points" (основная идея - сохранить правильно выбранный угол поворота для объекта при скрещивании)  

С такими параметрами оптимизация занимает значительное время, однако она позволяет найти глобальный минимум функции потерь, которая принимает значения >=0 и равняется нулю только на правильных укладках  

Решение данной задачи полным перебором является невозможным для нескольких предметов даже без введения возможности вращать предметы:  
(y_count * y_range)^(n_objects)  
Пусть изображение разбито сеткой с шагом в 1/20 по каждой из осей и дано 4 объекта  
Тогда необходимо будет произвести (20^2)^4 = 25600000000 вычислений в худшем случае  
Введение углов поворота ещё значительнее усугубит ситуацию  
В то же время данный алгоритм получил корреткную укладку для 6 и 5 объектов (см блокнот)

## План реализации
### Первоначальный алгоритм
- Обрабатываем объекты на эталонных фотографих(на фоне белого листа): ищем особые точки, сохраняем контур(детектор Кенни);
- Находим на верхней части изображения полигон и сохраняем его контур;
- Пытаемся сопоставить каждому эталонному объекту объект из композиции с помощью особых точек: используем число найденных особых точек для меры качества сопоставления. Например, для деревянного магнита найдено 250 особых точек, значит для него ожидается множество совпадений. Для маркера найдено 16 особых точек, поэтому достаточно 10 особых точек, чтобы сопоставить объекты;
- Укладываем объекты внутрь полигона. Сравниваем сумму площадей объектов с плозадью полигона.


## Планы по улучшению
1. В первую очередь нужно попытаться улучшить алгоритм детекции предметов - он самое узкое место текущей реализации. Теоретически SIFT должен справляться с данной задачей, однако на практике возникли следующие проблемы, которые необходимо решить:
 - Шумный фон. Ворс на полотенце создаёт множество особых точек. От него можно избавится с помощью фильтров;
 - Сомнительные особые точки для некоторых предметов. Необходимо улучшить алгоритм поиска особых точек и предобрабатывать входные данные, напр. увеличивать контрастность.
Если не удастся найти решение с особыми точками для всех объектов, можно попытаться использовать априорные знания о предметах, которые будут извлекаться в автоматическом режиме на этапе предобработки: цвет, размер, ...
2. Найти алгоритм для укладки контуров внутрь полигона. Вероятно, это оптимизационная задача, поэтому она должна быть решена в каком-то виде. Это позволит решать более сложные задачи успешно.


## Идея метода упаковки
Можно попытаться свести задачу к оптимизации некой функции, которая будет отражать качество упаковки. Это (в теории) позволит давать подробный ответ на поставленную задачу. Не просто отвечать, влезут ли предметы, но и указывать на степень их "невлезания". Или, например, можно будет сказать, какие ещё предметы могут поместиться в многоугольник, если исходные уже уложены в него.
### Предполагаемый вид функции
Функция должна быть определена над множеством контуров и принимать на вход трансформации для каждого контура: поворот и сдвиг.
f(polygon, contours[n], shifts[n], rotations[n])
Полигон и контуры должны быть определены бинарными матрицами, где все элементы вне контуров равны нулю, а элементы внутри контуров равны единицы (стандартная бин маска). При этом, полигон - это некая константа, которая может быть определена один раз и далее она не будет менятся.
Пусть нам дана маска полигона и n масок для контуров:
Тогда, можно суммировать все конутры с учётом их сдвигов и повортов. Получится новая матрица, в которой будут содержатсья значения от 0 до n (пиксель, где не было ни одного контура, равен нулю, и наоборот). 
Далее, нужно штрафовать неверные укладки следущим образом:
- Элементы сумированной маски, которые выходят за границу полигона и не равны нулю умножаем на большой штраф
- Элементы суммированной маски, которые лежат внутри полигона но не равны единице (пересечение контуров) умножаем на меньший штраф
- Заменяем в суммированной маске единицы на нули для исключения штрафа за правильную укладку
- Суммируме все элементы матрицы - получаем вес укладки. Для правильной укладки он равен нулю

### Оптимизация
Целевая функция является сложной, с точки зрения вычислений,поэтому необходимо применять эвристические алгоритмы для её оптимизации и стараться уменьшать число обращений к функции. Например, можно использовать генетический алгоритм оптимизации, для которого изначально необходимо подобрать приемлемые параметры. Например, подобрать сдвиги так, чтобы каждый контур находился внутри полигона. Далее, будут происходить мутации параметров, которые будут "искать" хорошее решение. На первых итерациях стоит увеличить скорость мутаций, а к концу, когда в популяции останутся адекватные особи, можно уменьшить скорость мутаций, чтобы не перескочить через правильную укладку

## Описание классов программы
*Object* - класс, оперирующий с предметами (хранит контуры, изображение, фильтры, умеет считать площадь)
*Polygon* - класс, реализующий полигон (хранит контур, изображение, умеет считать площадь и располагать внутри себя объекты класса *Object*)
*Scene* - класс, реализующий композицию (хранит объекты и полигон, организует связь между полигоном и объектами, находит на исходном иображении объекты и трансформирует их)
